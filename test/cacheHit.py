
# Generated by Gemini

# 참고 https://g.co/gemini/share/725cb81b7dd6

import time
import random

def access_sequential(data_structure):
    """데이터 구조의 요소를 순차적으로 접근합니다."""
    for i in range(len(data_structure)):
        _ = data_structure[i]  # 요소 접근

def access_random(data_structure, indices):
    """미리 생성된 무작위 순서의 인덱스를 사용하여 요소에 접근합니다."""
    for i in indices:
        _ = data_structure[i]  # 요소 접근

if __name__ == "__main__":
    # 데이터 크기를 CPU의 L1, L2 캐시보다 훨씬 크게 설정하여 효과를 극대화합니다.
    data_size = 20_000_000  # 예: 2천만 개 요소
    print(f"데이터 크기: {data_size:,}개 요소\n")

    # 테스트용 데이터 리스트 생성 (각기 다른 정수 객체)
    # 모든 요소가 동일 객체를 참조하지 않도록 하여 객체 자체 로딩 시간을 일정하게 만듭니다.
    print("테스트 데이터 생성 중...")
    data_list = [i for i in range(data_size)]
    print("데이터 생성 완료.\n")

    # 무작위 접근을 위한 인덱스 리스트 미리 생성 및 셔플
    # 이 시간은 측정에서 제외합니다.
    print("무작위 접근 인덱스 생성 중...")
    random_indices = list(range(data_size))
    random.shuffle(random_indices)
    print("인덱스 생성 완료.\n")

    # 1. 순차 접근 테스트 (높은 캐시 히트율 예상)
    print("순차 접근 테스트 시작...")
    start_time_seq = time.perf_counter()
    access_sequential(data_list)
    end_time_seq = time.perf_counter()
    sequential_access_time = end_time_seq - start_time_seq
    print(f"순차 접근 시간: {sequential_access_time:.6f} 초")

    # 2. 무작위 접근 테스트 (높은 캐시 미스율 예상)
    # 동일한 데이터에 대해 무작위 순서로 접근합니다.
    print("\n무작위 접근 테스트 시작...")
    start_time_rand = time.perf_counter()
    access_random(data_list, random_indices)
    end_time_rand = time.perf_counter()
    random_access_time = end_time_rand - start_time_rand
    print(f"무작위 접근 시간: {random_access_time:.6f} 초")

    # 성능 차이 비교
    if sequential_access_time > 0: # 0으로 나누는 오류 방지
        performance_difference = random_access_time / sequential_access_time
        print(f"\n성능 차이 (무작위 접근 / 순차 접근): {performance_difference:.2f} 배")
    else:
        print("\n순차 접근 시간이 0이거나 매우 작아 성능 차이를 계산할 수 없습니다.")

    print("\n--- 참고: 튜플을 사용한 테스트 ---")
    # 튜플은 불변(immutable)이며, 리스트와 마찬가지로 내부적으로 연속된 메모리에 요소의 참조를 저장합니다.
    # 따라서 캐시 접근 패턴에 따른 성능 경향은 리스트와 유사하게 나타납니다.
    print("테스트 데이터 (튜플) 생성 중...")
    data_tuple = tuple(i for i in range(data_size)) # 리스트 컴프리헨션 후 튜플 변환보다 제너레이터 표현식이 메모리 효율적
    print("데이터 생성 완료.\n")

    # 1. 튜플 순차 접근 테스트
    print("튜플 순차 접근 테스트 시작...")
    start_time_seq_tuple = time.perf_counter()
    access_sequential(data_tuple)
    end_time_seq_tuple = time.perf_counter()
    sequential_access_time_tuple = end_time_seq_tuple - start_time_seq_tuple
    print(f"튜플 순차 접근 시간: {sequential_access_time_tuple:.6f} 초")

    # 2. 튜플 무작위 접근 테스트
    print("\n튜플 무작위 접근 테스트 시작...")
    start_time_rand_tuple = time.perf_counter()
    access_random(data_tuple, random_indices) # 동일한 무작위 인덱스 사용
    end_time_rand_tuple = time.perf_counter()
    random_access_time_tuple = end_time_rand_tuple - start_time_rand_tuple
    print(f"튜플 무작위 접근 시간: {random_access_time_tuple:.6f} 초")

    if sequential_access_time_tuple > 0:
        performance_difference_tuple = random_access_time_tuple / sequential_access_time_tuple
        print(f"\n[튜플] 성능 차이 (무작위 접근 / 순차 접근): {performance_difference_tuple:.2f} 배")
    else:
        print("\n[튜플] 순차 접근 시간이 0이거나 매우 작아 성능 차이를 계산할 수 없습니다.")